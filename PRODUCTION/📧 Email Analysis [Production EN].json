{
  "name": "ğŸ“§ Email Analysis [Production EN]",
  "nodes": [
    {
      "parameters": {
        "content": "## ğŸ“§ Email Analysis - Email Dialog Analysis\n\n### Description\nThis workflow analyzes email correspondence with clients using AI.\nIt determines emotional tone, customer needs, missed opportunities\nand provides recommendations. Includes Lead Scoring.\n\n---\n\n### ğŸ”§ Setup\n\n1. **Open the `âš™ï¸ CONFIG` node** and configure:\n   - `api_key` â€” your API key to protect the endpoint\n   - `rate_limit_window_ms` â€” rate limiting window (ms)\n   - `rate_limit_max_requests` â€” max requests in window\n   - PostgreSQL table names\n\n2. **Connect PostgreSQL** credential to DB nodes\n\n3. **Connect Google Gemini API** credential\n\n4. **Activate the workflow**\n\n---\n\n### ğŸ“¡ API Endpoint\n\n**POST** `/webhook/analyze-email-dialog`\n\n**Headers:**\n```\nContent-Type: application/json\nx-api-key: your_api_key\n```\n\n**Body:**\n```json\n{\n  \"type\": \"single\",\n  \"email\": \"client@example.com\",\n  \"threadId\": \"thread_123\",\n  \"language\": \"en\",\n  \"userName\": \"John Smith\"\n}\n```\n\n**Parameters:**\n- `type` â€” analysis type: `single` (one email) or `all` (all dialogs)\n- `email` â€” client email for analysis\n- `language` â€” language filter for dialogs\n\n---\n\n### ğŸ“Š Analysis Result\n\n```json\n{\n  \"emotionalTone\": {\n    \"overall\": \"positive/negative/neutral\",\n    \"satisfaction\": 85\n  },\n  \"customerNeeds\": [\"...\"],\n  \"missedOpportunities\": [\"...\"],\n  \"recommendations\": [\"...\"],\n  \"leadScoring\": {\n    \"score\": 75,\n    \"temperature\": \"warm\"\n  }\n}\n```"
      },
      "id": "sticky-note-instructions",
      "name": "Sticky Note",
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        -2300,
        0
      ]
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "api-key",
              "name": "api_key",
              "value": "24fs-$r4d-defd-77ds-7eds",
              "type": "string"
            },
            {
              "id": "rate-window",
              "name": "rate_limit_window_ms",
              "value": 60000,
              "type": "number"
            },
            {
              "id": "rate-max",
              "name": "rate_limit_max_requests",
              "value": 60,
              "type": "number"
            },
            {
              "id": "table-language-settings",
              "name": "table_analysis_language_settings",
              "value": "analysis_language_settings",
              "type": "string"
            },
            {
              "id": "table-dialog-analysis",
              "name": "table_email_dialog_analysis",
              "value": "email_dialog_analysis",
              "type": "string"
            },
            {
              "id": "table-conversations",
              "name": "table_gmail_conversations",
              "value": "gmail_conversations",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "id": "config-node",
      "name": "âš™ï¸ CONFIG",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -2080,
        304
      ]
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "analyze-email-dialog",
        "responseMode": "responseNode",
        "options": {
          "allowedOrigins": "*",
          "responseHeaders": {
            "entries": [
              {
                "name": "Content-Type",
                "value": "application/json"
              }
            ]
          }
        }
      },
      "id": "01d39500-672d-41c3-a8e2-221b55d1ffd1",
      "name": "ğŸŒ Webhook: Analyze Email",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        -1888,
        304
      ],
      "webhookId": "analyze-email-dialog-webhook"
    },
    {
      "parameters": {
        "jsCode": "// ============================================\n// ğŸ” UNIVERSAL PROTECTION: API KEY + RATE LIMITING\n// ============================================\n\n// Get settings from CONFIG\nconst config = $('âš™ï¸ CONFIG').first().json;\nconst API_KEY = config.api_key;\nconst RATE_LIMIT_WINDOW_MS = config.rate_limit_window_ms;\nconst RATE_LIMIT_MAX_REQUESTS = config.rate_limit_max_requests;\n\nconst inputData = $('ğŸŒ Webhook: Analyze Email').item.json;\nconst body = inputData.body || {};\nconst headers = inputData.headers || {};\nconst query = inputData.query || {};\nconst clientIP = headers['x-real-ip'] || headers['x-forwarded-for'] || headers['cf-connecting-ip'] || 'unknown';\nconst now = Date.now();\n\n// RATE LIMITING\nconst staticData = $getWorkflowStaticData('global');\nif (!staticData.rateLimits) { staticData.rateLimits = {}; }\nfor (const ip in staticData.rateLimits) {\n  if (now - staticData.rateLimits[ip].firstRequest > RATE_LIMIT_WINDOW_MS) {\n    delete staticData.rateLimits[ip];\n  }\n}\nif (!staticData.rateLimits[clientIP]) {\n  staticData.rateLimits[clientIP] = { count: 1, firstRequest: now };\n} else {\n  staticData.rateLimits[clientIP].count++;\n  if (staticData.rateLimits[clientIP].count > RATE_LIMIT_MAX_REQUESTS) {\n    return [{ json: { ...inputData, authorized: false, error: { success: false, error: 'Too many requests', details: `Limit: ${RATE_LIMIT_MAX_REQUESTS} requests per minute`, status: 429, retryAfter: Math.ceil((staticData.rateLimits[clientIP].firstRequest + RATE_LIMIT_WINDOW_MS - now) / 1000) } } }];\n  }\n}\n\n// API KEY CHECK\nconst providedKey = headers['x-api-key'] || body.apiKey || query.apiKey || '';\nif (!providedKey) {\n  return [{ json: { ...inputData, authorized: false, error: { success: false, error: 'API key not provided', status: 401 } } }];\n}\nif (providedKey !== API_KEY) {\n  return [{ json: { ...inputData, authorized: false, error: { success: false, error: 'Invalid API key', status: 401 } } }];\n}\n\nreturn [{ json: { ...inputData, authorized: true } }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1728,
        304
      ],
      "id": "4be98bc3-982f-4bd3-914e-3ecd5c00c338",
      "name": "ğŸ” Security Check"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose",
            "version": 2
          },
          "conditions": [
            {
              "id": "auth-condition",
              "leftValue": "={{ $json.authorized }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -1552,
        304
      ],
      "id": "2123dfe0-4144-4331-879e-3f1ca7bf0ab4",
      "name": "ğŸ”€ Auth Check"
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json.error }}",
        "options": {
          "responseCode": "={{ $json.error.status }}"
        }
      },
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [
        -1344,
        464
      ],
      "id": "25607d76-07a2-4e06-b6fd-33daf46cf796",
      "name": "âŒ Error Response"
    },
    {
      "parameters": {
        "jsCode": "// Extract data from request\nconst data = $('ğŸŒ Webhook: Analyze Email').item.json.body || $('ğŸŒ Webhook: Analyze Email').item.json;\n\nconst analysisType = data.type || 'single';\nconst email = data.email;\nconst threadId = data.threadId;\nconst language = data.language;\n\nreturn [{\n    json: {\n        type: analysisType,\n        email: email,\n        threadId: threadId,\n        language: language,\n        userName: data.userName\n    }\n}];"
      },
      "id": "edfd5978-d604-4a74-a0ab-70dd7ea5883c",
      "name": "ğŸ“¥ Process Analysis Request",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1344,
        288
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "=-- Get analysis language from settings\nSELECT language_code \nFROM {{ $('âš™ï¸ CONFIG').first().json.table_analysis_language_settings }} \nORDER BY id DESC \nLIMIT 1;",
        "options": {}
      },
      "id": "f9c099c4-6342-465f-a65f-01b77685f46c",
      "name": "ğŸ“‹ Get Analysis Language",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        -1168,
        288
      ],
      "credentials": {
        "postgres": {
          "id": "dPjh4Kdb4nIbCTQG",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Get data from previous nodes\nconst requestData = $('ğŸ“¥ Process Analysis Request').first().json;\nconst langSetting = items[0]?.json?.language_code || 'ru';\n\n// Pass forward with analysis language\nreturn [{\n    json: {\n        type: requestData.type,\n        email: requestData.email,\n        threadId: requestData.threadId,\n        language: requestData.language,\n        userName: requestData.userName,\n        analysisLanguage: langSetting\n    }\n}];"
      },
      "id": "fd3f462c-a5c0-4339-9b2e-3d3d0a149bfe",
      "name": "ğŸ”„ Merge with Language",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1008,
        288
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "=-- Check for new email messages and get previous analysis\nWITH last_analysis AS (\n    SELECT \n        email,\n        updated_at as analysis_date,\n        emotional_tone,\n        customer_needs,\n        missed_opportunities,\n        recommendations,\n        lead_scoring,\n        statistics,\n        satisfaction_percentage\n    FROM {{ $('âš™ï¸ CONFIG').first().json.table_email_dialog_analysis }}\n    WHERE email = '{{ $('ğŸ”„ Merge with Language').first().json.email }}'\n    ORDER BY updated_at DESC\n    LIMIT 1\n),\nconversation_data AS (\n    SELECT \n        email,\n        updated_at as conversation_updated,\n        message_count\n    FROM {{ $('âš™ï¸ CONFIG').first().json.table_gmail_conversations }}\n    WHERE email = '{{ $('ğŸ”„ Merge with Language').first().json.email }}'\n    ORDER BY updated_at DESC\n    LIMIT 1\n)\nSELECT \n    COALESCE(cd.email, '{{ $('ğŸ”„ Merge with Language').first().json.email }}') as email,\n    cd.conversation_updated,\n    cd.message_count,\n    la.analysis_date as last_analysis_date,\n    CASE \n        WHEN cd.conversation_updated IS NULL THEN false\n        WHEN la.analysis_date IS NULL THEN true\n        WHEN cd.conversation_updated > la.analysis_date THEN true \n        ELSE false \n    END as has_new_messages,\n    la.emotional_tone as prev_emotional_tone,\n    la.customer_needs as prev_customer_needs,\n    la.missed_opportunities as prev_missed_opportunities,\n    la.recommendations as prev_recommendations,\n    la.lead_scoring as prev_lead_scoring,\n    la.statistics as prev_statistics,\n    la.satisfaction_percentage as prev_satisfaction\nFROM conversation_data cd\nFULL OUTER JOIN last_analysis la ON true;",
        "options": {}
      },
      "id": "ea5d5b04-d3cb-4f6a-bc2c-8f51be47b982",
      "name": "ğŸ” Check New Messages",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        -832,
        288
      ],
      "credentials": {
        "postgres": {
          "id": "dPjh4Kdb4nIbCTQG",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Merge data from Check for New Email Messages with data from Merge with Language\nconst checkResult = items[0].json;\nconst mergedData = $('ğŸ”„ Merge with Language').first().json;\n\n// Parse JSONB fields of previous analysis\nconst parseJsonField = (field) => {\n    if (!field) return null;\n    if (typeof field === 'string') {\n        try {\n            return JSON.parse(field);\n        } catch (e) {\n            return field;\n        }\n    }\n    return field;\n};\n\n// Form previous analysis object\nconst previousAnalysis = checkResult.last_analysis_date ? {\n    emotionalTone: parseJsonField(checkResult.prev_emotional_tone),\n    customerNeeds: parseJsonField(checkResult.prev_customer_needs),\n    missedOpportunities: parseJsonField(checkResult.prev_missed_opportunities),\n    recommendations: parseJsonField(checkResult.prev_recommendations),\n    leadScoring: parseJsonField(checkResult.prev_lead_scoring),\n    statistics: parseJsonField(checkResult.prev_statistics),\n    satisfaction: checkResult.prev_satisfaction,\n    analysisDate: checkResult.last_analysis_date\n} : null;\n\nreturn [{\n    json: {\n        // Data from Merge with Language\n        type: mergedData.type,\n        email: mergedData.email,\n        threadId: mergedData.threadId,\n        language: mergedData.language,\n        userName: mergedData.userName,\n        analysisLanguage: mergedData.analysisLanguage,\n        \n        // Data from Check for New Email Messages\n        has_new_messages: checkResult.has_new_messages,\n        conversation_updated: checkResult.conversation_updated,\n        last_analysis_date: checkResult.last_analysis_date,\n        message_count: checkResult.message_count,\n        \n        // Previous analysis to pass to AI\n        previousAnalysis: previousAnalysis\n    }\n}];"
      },
      "id": "b3a1265f-5420-4d97-9cf5-5331da40bf6a",
      "name": "ğŸ”€ Merge Check Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -624,
        288
      ]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "check-new-email-messages",
              "leftValue": "={{ $json.has_new_messages }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "true"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "ca5a0d73-2f35-480e-af52-bf23a60b5dc6",
      "name": "ğŸ”€ Has New Messages?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        -416,
        288
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "=-- Get existing email analysis\nSELECT \n    email,\n    analysis_type,\n    emotional_tone,\n    customer_needs,\n    missed_opportunities,\n    recommendations,\n    lead_scoring,\n    statistics,\n    satisfaction_percentage,\n    created_at,\n    updated_at\nFROM {{ $('âš™ï¸ CONFIG').first().json.table_email_dialog_analysis }}\nWHERE email = '{{ $('ğŸ”€ Merge Check Data').first().json.email }}'\nORDER BY updated_at DESC\nLIMIT 1;",
        "options": {}
      },
      "id": "3be2e34c-477e-4369-bada-82dcad647219",
      "name": "ğŸ“‹ Get Existing Analysis",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        -208,
        512
      ],
      "credentials": {
        "postgres": {
          "id": "dPjh4Kdb4nIbCTQG",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Format existing email analysis for return\nconst existingAnalysis = items[0].json;\nconst checkData = $('ğŸ”€ Merge Check Data').first().json;\n\n// Parse JSONB fields if they are strings\nconst parseJsonField = (field) => {\n    if (!field) return null;\n    if (typeof field === 'string') {\n        try {\n            return JSON.parse(field);\n        } catch (e) {\n            return field;\n        }\n    }\n    return field;\n};\n\nreturn [{\n    json: {\n        // Main analysis fields\n        emotionalTone: parseJsonField(existingAnalysis.emotional_tone),\n        customerNeeds: parseJsonField(existingAnalysis.customer_needs),\n        missedOpportunities: parseJsonField(existingAnalysis.missed_opportunities),\n        recommendations: parseJsonField(existingAnalysis.recommendations),\n        leadScoring: parseJsonField(existingAnalysis.lead_scoring),\n        statistics: parseJsonField(existingAnalysis.statistics),\n        \n        // Email identifier\n        email: existingAnalysis.email || checkData.email,\n        \n        // Caching metadata\n        _cached: true,\n        _lastAnalysisDate: checkData.last_analysis_date,\n        _conversationUpdated: checkData.conversation_updated,\n        _messageCount: checkData.message_count\n    }\n}];"
      },
      "id": "e3816139-e0d0-4bc4-ac17-23022dcbb0fb",
      "name": "ğŸ“ Format Existing Analysis",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        0,
        512
      ]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": {}
      },
      "id": "2c8b3358-1943-43bd-abfc-4be44472ce4a",
      "name": "ğŸ“¤ Return Cached Result",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [
        208,
        512
      ]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "leftValue": "={{ $json.type }}",
              "rightValue": "single",
              "operator": {
                "type": "string",
                "operation": "equals"
              },
              "id": "single-analysis-check"
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "75c2e9fd-dcb0-44e3-9829-4bad1a97239a",
      "name": "ğŸ”€ Analysis Type?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        -208,
        96
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "=-- Get email dialog for analysis (only new messages if there's a previous analysis)\nSELECT \n    gc.email,\n    gc.thread_id,\n    gc.subject,\n    gc.messages,\n    gc.status,\n    gc.lead_score,\n    gc.language,\n    gc.message_count,\n    gc.created_at,\n    gc.updated_at,\n    '{{ $('ğŸ”€ Merge Check Data').first().json.last_analysis_date }}' as last_analysis_date\nFROM {{ $('âš™ï¸ CONFIG').first().json.table_gmail_conversations }} gc\nWHERE gc.email = '{{ $('ğŸ”€ Merge Check Data').first().json.email }}'\nORDER BY gc.updated_at DESC\nLIMIT 1;",
        "options": {}
      },
      "id": "6d81e7db-4c56-474a-9927-373aa6a23d53",
      "name": "ğŸ“§ Get Single Dialog",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        0,
        0
      ],
      "credentials": {
        "postgres": {
          "id": "dPjh4Kdb4nIbCTQG",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "=-- Get all email dialogs for analysis\nSELECT \n    gc.email,\n    gc.thread_id,\n    gc.subject,\n    gc.messages,\n    gc.status,\n    gc.lead_score,\n    gc.language,\n    gc.message_count,\n    gc.created_at,\n    gc.updated_at,\n    '{{ $('ğŸ”€ Merge Check Data').first().json.last_analysis_date }}' as last_analysis_date\nFROM {{ $('âš™ï¸ CONFIG').first().json.table_gmail_conversations }} gc\nWHERE \n    gc.created_at >= NOW() - INTERVAL '30 days'\n    {{ $('ğŸ”€ Merge Check Data').first().json.language ? \"AND gc.language = '\" + $('ğŸ”€ Merge Check Data').first().json.language + \"'\" : \"\" }}\nORDER BY gc.updated_at DESC;",
        "options": {}
      },
      "id": "4e033833-ef48-4c6f-a0d0-ec6fb19e7c2e",
      "name": "ğŸ“§ Get All Dialogs",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        0,
        192
      ],
      "credentials": {
        "postgres": {
          "id": "dPjh4Kdb4nIbCTQG",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Format email dialogs for analysis\nconst dialogs = items;\nconst mergedData = $('ğŸ”€ Merge Check Data').first().json;\nconst analysisType = mergedData.type;\nconst analysisLanguage = mergedData.analysisLanguage || 'ru';\nconst lastAnalysisDate = mergedData.last_analysis_date;\nconst previousAnalysis = mergedData.previousAnalysis;\n\n// Group by email\nconst emailDialogs = {};\n\ndialogs.forEach(item => {\n    const data = item.json;\n    const email = data.email;\n    \n    if (!emailDialogs[email]) {\n        // Parse messages\n        let messages = [];\n        try {\n            messages = typeof data.messages === 'string' \n                ? JSON.parse(data.messages) \n                : data.messages || [];\n        } catch (e) {\n            messages = [];\n        }\n        \n        // If there's previous analysis - filter only NEW messages\n        let filteredMessages = messages;\n        let allMessages = messages;\n        \n        if (lastAnalysisDate && lastAnalysisDate !== 'null' && lastAnalysisDate !== '') {\n            const lastAnalysisTime = new Date(lastAnalysisDate).getTime();\n            filteredMessages = messages.filter(msg => {\n                const msgTime = new Date(msg.date).getTime();\n                return msgTime > lastAnalysisTime;\n            });\n        }\n        \n        emailDialogs[email] = {\n            email: email,\n            threadId: data.thread_id,\n            subject: data.subject,\n            language: data.language,\n            messageCount: data.message_count || messages.length,\n            newMessageCount: filteredMessages.length,\n            leadScore: data.lead_score,\n            messages: filteredMessages,\n            allMessages: allMessages\n        };\n    }\n});\n\n// Prepare data for AI considering language\nconst dialogsForAnalysis = Object.values(emailDialogs).map((dialog) => {\n    // Select correct labels depending on analysis language\n    const clientLabel = analysisLanguage === 'en' ? 'Client' : \n                        analysisLanguage === 'es' ? 'Cliente' : \n                        analysisLanguage === 'fr' ? 'Client' : \n                        analysisLanguage === 'de' ? 'Kunde' : \n                        analysisLanguage === 'it' ? 'Cliente' : \n                        analysisLanguage === 'pt' ? 'Cliente' : \n                        analysisLanguage === 'zh' ? 'å®¢æˆ·' : \n                        analysisLanguage === 'ja' ? 'é¡§å®¢' : \n                        analysisLanguage === 'ko' ? 'ê³ ê°' : \n                        analysisLanguage === 'ua' ? 'ĞšĞ»Ñ–Ñ”Ğ½Ñ‚' : \n                        'ĞšĞ»Ğ¸ĞµĞ½Ñ‚';\n    \n    const botLabel = analysisLanguage === 'en' ? 'Bot' : \n                     analysisLanguage === 'es' ? 'Bot' : \n                     analysisLanguage === 'fr' ? 'Bot' : \n                     analysisLanguage === 'de' ? 'Bot' : \n                     analysisLanguage === 'it' ? 'Bot' : \n                     analysisLanguage === 'pt' ? 'Bot' : \n                     analysisLanguage === 'zh' ? 'æœºå™¨äºº' : \n                     analysisLanguage === 'ja' ? 'ãƒœãƒƒãƒˆ' : \n                     analysisLanguage === 'ko' ? 'ë´‡' : \n                     analysisLanguage === 'ua' ? 'Ğ‘Ğ¾Ñ‚' : \n                     'Ğ‘Ğ¾Ñ‚';\n    \n    const conversation = dialog.messages.map(msg => \n        `${msg.type === 'incoming' ? clientLabel : botLabel}: ${msg.content}`\n    ).join('\\n');\n    \n    return {\n        email: dialog.email,\n        threadId: dialog.threadId,\n        subject: dialog.subject,\n        language: dialog.language,\n        conversation: conversation,\n        newMessageCount: dialog.newMessageCount,\n        totalMessageCount: dialog.allMessages.length\n    };\n});\n\n// Determine if this is first analysis or update\nconst isUpdate = !!previousAnalysis;\n\nreturn [{\n    json: {\n        type: analysisType,\n        email: mergedData.email,\n        dialogs: dialogsForAnalysis,\n        totalDialogs: dialogsForAnalysis.length,\n        analysisLanguage: analysisLanguage,\n        isUpdate: isUpdate,\n        previousAnalysis: previousAnalysis\n    }\n}];"
      },
      "id": "40708d1b-9fc9-4a5f-9698-f7681dcc80d1",
      "name": "ğŸ“ Format Dialogs for AI",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        208,
        96
      ]
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=Output language: {{ $json.analysisLanguage || 'ru' }}\nREQUIRED: Generate ALL text fields of the response in the language: {{ \n  $json.analysisLanguage === 'ru' ? 'Russian' : \n  $json.analysisLanguage === 'en' ? 'English' : \n  $json.analysisLanguage === 'es' ? 'Spanish' : \n  $json.analysisLanguage === 'fr' ? 'French' : \n  $json.analysisLanguage === 'de' ? 'German' : \n  $json.analysisLanguage === 'it' ? 'Italian' : \n  $json.analysisLanguage === 'pt' ? 'Portuguese' : \n  $json.analysisLanguage === 'zh' ? 'Chinese' : \n  $json.analysisLanguage === 'ja' ? 'Japanese' : \n  $json.analysisLanguage === 'ko' ? 'Korean' : \n  $json.analysisLanguage === 'ua' ? 'Ukrainian' : \n  'Russian' \n}}\n\nAnalysis type: {{ $json.type }}\nMode: {{ $json.isUpdate ? 'UPDATE of existing analysis' : 'INITIAL analysis' }}\n\n{{ $json.isUpdate && $json.previousAnalysis ? `\n========================================\nPREVIOUS ANALYSIS (use as base for update):\n========================================\n\nEmotional tone: ${JSON.stringify($json.previousAnalysis.emotionalTone, null, 2)}\n\nCustomer needs: ${JSON.stringify($json.previousAnalysis.customerNeeds, null, 2)}\n\nMissed opportunities: ${JSON.stringify($json.previousAnalysis.missedOpportunities, null, 2)}\n\nRecommendations: ${JSON.stringify($json.previousAnalysis.recommendations, null, 2)}\n\nLead Scoring: ${JSON.stringify($json.previousAnalysis.leadScoring, null, 2)}\n\nStatistics: ${JSON.stringify($json.previousAnalysis.statistics, null, 2)}\n\n========================================\nNEW MESSAGES FOR ANALYSIS:\n========================================\n` : '========================================\\nDIALOGS FOR INITIAL ANALYSIS:\\n========================================\\n' }}\n\n{{ $json.dialogs.map((d, i) => `\n--- Email dialog ${i+1} (${d.email}, ${d.language}) ---\nSubject: ${d.subject}\n${ $json.isUpdate ? `New messages: ${d.newMessageCount} out of ${d.totalMessageCount} total` : `Total messages: ${d.totalMessageCount}` }\n\n${d.conversation}`).join('\\n\\n') }}",
        "options": {
          "systemMessage": "=#Role: You are a specialist in analyzing email correspondence between clients and Cryptomator company.\n\n---\n\n# ğŸ”´ CRITICALLY IMPORTANT - OUTPUT LANGUAGE\n\n**ALL text fields of the analysis result MUST be in the language specified in \"Output language\"!**\n\nThis includes:\n- All descriptions in emotionalTone (overall, overallText, description)\n- ALL elements of customerNeeds, missedOpportunities, recommendations arrays\n- All text fields in leadScoring (recommendation)\n- All text fields in statistics\n\n**Regardless of the dialog language, the result must be in the specified output language!**\n\n---\n\n# ğŸ”„ OPERATING MODE\n\n## If this is an UPDATE of existing analysis:\n1. **Use previous analysis as base** â€” don't start from scratch\n2. **Analyze only NEW messages** â€” they are provided separately\n3. **UPDATE existing data** based on new information:\n   - Lead Score may increase or decrease\n   - New needs may appear (add to existing)\n   - Emotional tone may change\n   - Recommendations may be updated\n4. **Preserve relevant history** â€” don't delete important data from previous analysis\n5. **Note changes** â€” if Lead Score changed, reflect this in recommendation\n\n## If this is INITIAL analysis:\n- Analyze the entire provided dialog from scratch\n- Follow standard analysis criteria\n\n---\n\n#Task: Analyze email dialogs and evaluate interaction effectiveness, identify customer needs, determine missed sales opportunities and provide recommendations for improvement.\n\n#Analysis criteria:\n\n1. **Email correspondence emotional tone**:\n   - Determine overall emotional tone (positive, negative, neutral)\n   - Assess customer satisfaction level (0-100%)\n   - Describe emotion dynamics in the dialog\n\n2. **Identified customer needs**:\n   - List explicit needs and requests\n   - Identify most frequent questions\n   - Reveal hidden needs\n\n3. **Missed sales opportunities**:\n   - Highlight moments for additional offers\n   - Point out unresolved problems\n   - Identify cases of incomplete answers\n\n4. **Improvement recommendations**:\n   - Suggest specific improvements for responses\n   - Recommend follow-up topics\n   - Indicate necessary approach changes\n\n# Lead Scoring for Email (0-100 points):\n\n## Evaluation criteria:\n\n### 1. Satisfaction and tone (0-25 points)\n- 20-25: Very satisfied customer, positive tone\n- 15-19: Satisfied, neutral-positive\n- 10-14: Neutral\n- 5-9: Some dissatisfaction\n- 0-4: Clear dissatisfaction\n\n### 2. Contact data quality (0-20 points)\n- Full name in signature: +5\n- Position: +5\n- Company: +5\n- Phone in signature: +5\n\n### 3. Activity and engagement (0-15 points)\n- Number of client responses\n- Response speed\n- Length and substance of emails\n- Asks clarifying questions\n\n### 4. Purchase intentions (0-25 points)\n- Direct price questions: +10\n- Feature questions: +5\n- Demo/presentation request: +10\n- Comparing with competitors: +5\n\n### 5. Need urgency (0-15 points)\n- \"Urgently need\": 15\n- \"This month\": 10\n- \"Planning\": 5\n- \"Maybe later\": 2\n\n## Lead temperature:\n- **hot**: 80-100 points\n- **warm**: 50-79 points\n- **cold**: 0-49 points\n\n---\n\n#Response format - clean JSON without markdown:\n{\n  \"emotionalTone\": {\n    \"overall\": \"positive/negative/neutral\",\n    \"overallText\": \"brief tone description\",\n    \"satisfaction\": number (0-100),\n    \"description\": \"detailed description of emotional dynamics\"\n  },\n  \"customerNeeds\": [\"list of needs\"],\n  \"missedOpportunities\": [\"list of missed opportunities\"],\n  \"recommendations\": [\"list of recommendations\"],\n  \"statistics\": {\n    \"totalDialogs\": number,\n    \"avgSatisfaction\": number,\n    \"resolvedPercentage\": number\n  },\n  \"leadScoring\": {\n    \"score\": number (0-100),\n    \"temperature\": \"hot/warm/cold\",\n    \"factors\": {\n      \"satisfaction\": number,\n      \"contacts\": number,\n      \"engagement\": number,\n      \"intentions\": number,\n      \"urgency\": number\n    },\n    \"recommendation\": \"recommendation for working with lead\"\n  }\n}\n\n---\n\n# IMPORTANT\n\n1. **CRITICALLY IMPORTANT:** Return ONLY clean JSON without markdown, triple quotes or additional text!\n\n2. **Response language:** ALL text fields must be in the language specified in \"Output language\", regardless of correspondence language!\n\n3. **When updating:** If this is an update â€” consider previous analysis, don't ignore it!\n\n4. **Detail balance:** Analysis should be informative but compact\n\n5. **Context matters more than words:** Defensive mechanisms often hide real interest"
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2,
      "position": [
        416,
        96
      ],
      "id": "416e21fb-86d4-4027-8b2e-691ace79ff85",
      "name": "ğŸ¤– Email AI Agent"
    },
    {
      "parameters": {
        "options": {
          "temperature": 0.3
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatGoogleGemini",
      "typeVersion": 1,
      "position": [
        336,
        304
      ],
      "id": "f76a2136-6889-448a-ae3f-079718493e2d",
      "name": "ğŸ§  Google Gemini",
      "credentials": {
        "googlePalmApi": {
          "id": "abo0BDHSJPM0pgRU",
          "name": "Google Gemini(PaLM) Api account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Parse AI agent response\nconst aiResponse = items[0].json;\nconst mergedData = $('ğŸ”€ Merge Check Data').first().json;\n\nlet responseText = '';\nlet parsedResponse = null;\n\n// Get response text\nif (aiResponse.output) {\n    responseText = aiResponse.output;\n} else if (aiResponse.text) {\n    responseText = aiResponse.text;\n} else if (typeof aiResponse === 'string') {\n    responseText = aiResponse;\n} else if (aiResponse.emotionalTone) {\n    parsedResponse = aiResponse;\n}\n\n// Parse if there's text\nif (!parsedResponse && responseText) {\n    let cleanJson = responseText.trim();\n    \n    // Remove markdown\n    if (cleanJson.startsWith('```json')) {\n        cleanJson = cleanJson.substring(7);\n    } else if (cleanJson.startsWith('```')) {\n        cleanJson = cleanJson.substring(3);\n    }\n    if (cleanJson.endsWith('```')) {\n        cleanJson = cleanJson.substring(0, cleanJson.length - 3);\n    }\n    cleanJson = cleanJson.trim();\n    \n    // Attempt 1: direct parsing\n    try {\n        parsedResponse = JSON.parse(cleanJson);\n    } catch (e1) {\n        // Attempt 2: JSON extraction\n        try {\n            const firstBrace = cleanJson.indexOf('{');\n            const lastBrace = cleanJson.lastIndexOf('}');\n            if (firstBrace !== -1 && lastBrace > firstBrace) {\n                parsedResponse = JSON.parse(cleanJson.substring(firstBrace, lastBrace + 1));\n            }\n        } catch (e2) {\n            // Attempt 3: escape handling\n            try {\n                let fixedJson = cleanJson;\n                if (fixedJson.startsWith('\"') && fixedJson.endsWith('\"')) {\n                    fixedJson = fixedJson.slice(1, -1);\n                }\n                fixedJson = fixedJson.replace(/\\\\\\\\n/g, '\\\\n').replace(/\\\\\\\\t/g, '\\\\t');\n                const fb = fixedJson.indexOf('{');\n                const lb = fixedJson.lastIndexOf('}');\n                if (fb !== -1 && lb > fb) {\n                    parsedResponse = JSON.parse(fixedJson.substring(fb, lb + 1));\n                }\n            } catch (e3) {}\n        }\n    }\n}\n\n// Fallback on error\nif (!parsedResponse) {\n    parsedResponse = {\n        emotionalTone: { overall: 'neutral', overallText: 'Parsing error', satisfaction: 50, description: 'Error parsing AI response' },\n        customerNeeds: ['Re-analysis required'],\n        missedOpportunities: ['Data unavailable'],\n        recommendations: ['Repeat analysis'],\n        statistics: { totalDialogs: 1, avgSatisfaction: 50, resolvedPercentage: 0 },\n        leadScoring: { score: 0, temperature: 'cold', factors: { satisfaction: 0, contacts: 0, engagement: 0, intentions: 0, urgency: 0 }, recommendation: 'Re-analysis required' }\n    };\n}\n\nparsedResponse.email = mergedData.email;\n\nreturn [{ json: parsedResponse }];"
      },
      "id": "7c2e185b-10af-439e-a4f7-adb155c0c00f",
      "name": "ğŸ“Š Parse AI Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        816,
        96
      ]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": {}
      },
      "id": "f558a9da-8986-4ba4-af6a-78f23e2f1e98",
      "name": "ğŸ“¤ Send Analysis Result",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [
        1008,
        16
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "=-- Save email analysis results (all fields as JSONB)\nINSERT INTO {{ $('âš™ï¸ CONFIG').first().json.table_email_dialog_analysis }} (\n    email,\n    analysis_type,\n    emotional_tone,\n    customer_needs,\n    missed_opportunities,\n    recommendations,\n    lead_scoring,\n    statistics,\n    satisfaction_percentage,\n    created_at\n) VALUES (\n    '{{ $json.email }}',\n    'single',\n    $js${{ JSON.stringify($json.emotionalTone) }}$js$::jsonb,\n    $js${{ JSON.stringify($json.customerNeeds) }}$js$::jsonb,\n    $js${{ JSON.stringify($json.missedOpportunities) }}$js$::jsonb,\n    $js${{ JSON.stringify($json.recommendations) }}$js$::jsonb,\n    $js${{ JSON.stringify($json.leadScoring) }}$js$::jsonb,\n    $js${{ JSON.stringify($json.statistics) }}$js$::jsonb,\n    {{ $json.emotionalTone?.satisfaction || $json.statistics?.avgSatisfaction || 0 }},\n    NOW()\n)\nON CONFLICT (email) DO UPDATE SET\n    emotional_tone = EXCLUDED.emotional_tone,\n    customer_needs = EXCLUDED.customer_needs,\n    missed_opportunities = EXCLUDED.missed_opportunities,\n    recommendations = EXCLUDED.recommendations,\n    lead_scoring = EXCLUDED.lead_scoring,\n    statistics = EXCLUDED.statistics,\n    satisfaction_percentage = EXCLUDED.satisfaction_percentage,\n    updated_at = NOW()\nRETURNING *;",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        1008,
        208
      ],
      "id": "0b1c331e-a02d-43a5-9fac-c2875931e75d",
      "name": "ğŸ’¾ Save Analysis",
      "credentials": {
        "postgres": {
          "id": "dPjh4Kdb4nIbCTQG",
          "name": "Postgres account"
        }
      }
    }
  ],
  "pinData": {},
  "connections": {
    "âš™ï¸ CONFIG": {
      "main": [
        [
          {
            "node": "ğŸŒ Webhook: Analyze Email",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ğŸŒ Webhook: Analyze Email": {
      "main": [
        [
          {
            "node": "ğŸ” Security Check",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ğŸ” Security Check": {
      "main": [
        [
          {
            "node": "ğŸ”€ Auth Check",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ğŸ”€ Auth Check": {
      "main": [
        [
          {
            "node": "ğŸ“¥ Process Analysis Request",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "âŒ Error Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ğŸ“¥ Process Analysis Request": {
      "main": [
        [
          {
            "node": "ğŸ“‹ Get Analysis Language",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ğŸ“‹ Get Analysis Language": {
      "main": [
        [
          {
            "node": "ğŸ”„ Merge with Language",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ğŸ”„ Merge with Language": {
      "main": [
        [
          {
            "node": "ğŸ” Check New Messages",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ğŸ” Check New Messages": {
      "main": [
        [
          {
            "node": "ğŸ”€ Merge Check Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ğŸ”€ Merge Check Data": {
      "main": [
        [
          {
            "node": "ğŸ”€ Has New Messages?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ğŸ”€ Has New Messages?": {
      "main": [
        [
          {
            "node": "ğŸ”€ Analysis Type?",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "ğŸ“‹ Get Existing Analysis",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ğŸ“‹ Get Existing Analysis": {
      "main": [
        [
          {
            "node": "ğŸ“ Format Existing Analysis",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ğŸ“ Format Existing Analysis": {
      "main": [
        [
          {
            "node": "ğŸ“¤ Return Cached Result",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ğŸ”€ Analysis Type?": {
      "main": [
        [
          {
            "node": "ğŸ“§ Get Single Dialog",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "ğŸ“§ Get All Dialogs",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ğŸ“§ Get Single Dialog": {
      "main": [
        [
          {
            "node": "ğŸ“ Format Dialogs for AI",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ğŸ“§ Get All Dialogs": {
      "main": [
        [
          {
            "node": "ğŸ“ Format Dialogs for AI",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ğŸ“ Format Dialogs for AI": {
      "main": [
        [
          {
            "node": "ğŸ¤– Email AI Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ğŸ¤– Email AI Agent": {
      "main": [
        [
          {
            "node": "ğŸ“Š Parse AI Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ğŸ§  Google Gemini": {
      "ai_languageModel": [
        [
          {
            "node": "ğŸ¤– Email AI Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "ğŸ“Š Parse AI Response": {
      "main": [
        [
          {
            "node": "ğŸ“¤ Send Analysis Result",
            "type": "main",
            "index": 0
          },
          {
            "node": "ğŸ’¾ Save Analysis",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "53710e37-b733-4ec5-b381-66161fd724dc",
  "meta": {
    "instanceId": "9a2a948e1b1119e76dce477f4f08641c41898f344f4216cb90098437b1dcaf00"
  },
  "id": "xPxOYs0EDQVVEd0R",
  "tags": []
}
